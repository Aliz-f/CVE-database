from tempfile import TemporaryFile
from rest_framework import status, permissions, authentication
from rest_framework.views import APIView
from rest_framework.response import Response

from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank

from .models import *
from .serializers import *
from .utils import nvdDb

# Create your views here.

class CsrfExemptSessionAuthentication(authentication.SessionAuthentication):
    def enforce_csrf(self, request):
        return

class createCPE(APIView):
    #TODO Permissions
    permission_classes = (permissions.AllowAny,)
    authentication_classes = (CsrfExemptSessionAuthentication, 
    authentication.SessionAuthentication,)

    def post(self, request):
        '''
            save product in database, 
            for each product save all cpes,
            for each cpe, save all cves and if cve exists in db , add ship for cpe and cve 
            if ok:
                product, cpes and cves saved -> status HTTP_201_CREATED
            erorrs:
                1- if product exsist in database -> status HTTP_302_FOUND
                2- if product, cpe, cve data format not valid -> status HTTP_406_NOT_ACCEPTABLE
                3- if cpe list empty -> status HTTP_404_NOT_FOUND
        '''
        try:
            data = request.data
            type = data.get('type')
            Reqvendor = data.get('vendor')
            Reqproduct = data.get('name')
            cpeIter = 0
            cveIter = 0
            cpe_CveShipIter = 0
            productQuery = product.objects.filter(name=Reqproduct)
            if productQuery.exists():
                return Response({'details':'product exists in database'},
                     status=status.HTTP_302_FOUND)
            productSer = productSerializer(data=data)
            if productSer.is_valid():
                productSaved = productSer.save()
            else:
                return Response(productSer.errors, status=status.HTTP_406_NOT_ACCEPTABLE)
            nvd = nvdDb(Reqvendor, Reqproduct, type)
            for eachCpe in nvd.cpes:
                cpeSerializer = cpeVulnerabilitySerializer(data=eachCpe)
                if cpeSerializer.is_valid():
                    cpeSaved = cpeSerializer.save()
                    cpeIter+=1
                    print(cpeSaved, cpeIter)
                    productCpeShip.objects.create(whichProduct =productSaved, whichCpe = cpeSaved)
                    nvd.searchCVE(cpeSaved.name)
                    for eachVuln in nvd.cves[cpeSaved.name]:
                        cveQuery = cveVulnerability.objects.filter(cveId=eachVuln["cveId"]) 
                        if cveQuery.exists():
                            cveAndCpeShip.objects.create(whichCpe=cpeSaved, whichCve=cveQuery[0])
                            cpe_CveShipIter+=1
                            print("cpe - cve ship", cpe_CveShipIter)
                        else:
                            cveSerializer = cveVulnerabilitySerializer(data=eachVuln)
                            if cveSerializer.is_valid():
                                cveSaved = cveSerializer.save()
                                cveAndCpeShip.objects.create(whichCpe=cpeSaved, whichCve=cveSaved )
                                cveIter+=1
                                print(cveSaved, cveIter)
                            else:
                                return Response(cveSerializer.errors, status=status.HTTP_406_NOT_ACCEPTABLE)
                else:
                    return Response(cpeSerializer.errors, status=status.HTTP_406_NOT_ACCEPTABLE)
            if cpeIter==0 and cveIter==0:
                return Response(status=status.HTTP_406_NOT_ACCEPTABLE)
            return Response({'details':f'{cpeIter} cpes saved and {cveIter} cves saved'}, status=status.HTTP_201_CREATED)
        except Exception as e :
            return Response({'details':str(e)}, status=status.HTTP_400_BAD_REQUEST)

    def get(self, request):
        '''
            query params : 
            1- product -> string (required)
            2- vendor -> string (required)
            3- version -> string (required)
            4- edition -> list of strings (optional)
            if ok:
                "<cpeName>": [
                {
                    "id": <number>,
                    "cveId": "string",
                    "dataType": "string",
                    "dataFormat": "string",
                    "dataVersion": "string",
                    "assigner": "string",
                    "problemtype": {},
                    "references": {},
                    "description": {},
                    "configurations": {},
                    "baseMetricV3": {},
                    "baseMetricV2": {},
                    "publishedDate": "datetime_date",
                    "lastModifiedDate": "datetime_date",
                    "cwe": {},
                    "url": "url_field",
                    "v3score": <number - float>,
                    "v3vector": "string",
                    "v3severity": "string",
                    "v3exploitability": <number - float>,
                    "v3impactScore": <number - float>,
                    "v2score": <number - float>,
                    "v2vector": "string",
                    "v2severity": "string",
                    "v2exploitability":<number - float>,
                    "v2impactScore": <number - float>,
                    "score": []
                },...
                response cpe with all cve -> status HTTP_200_OK
            errors:
                if product not exists -> status HTTP_400_BAD_REQUEST

        '''
        try:
            data =dict()
            reqProduct =  request.GET.get('product')
            reqVendor = request.GET.get('vendor')
            version = request.GET.get('version')
            edition = request.GET.get('edition')
            assert reqProduct and reqVendor and version, 'vendor, product and version not found'
            productQuery = product.objects.get(name=reqProduct, vendor=reqVendor)
            cpeQuery = productQuery.cpes.all()
            search_vector = SearchVector('versionPart1',weight="A")
            search_query = SearchQuery(version)
            cpeQuery = cpeQuery.annotate(rank=SearchRank(search_vector,search_query)).filter(rank__gt=0.5).order_by('-rank')
            if edition:
                edition = edition.split(',')
                for eachEdi in edition:
                    search_vector = SearchVector('versionPart2',weight="A")+SearchVector('versionPart3',weight="A")+SearchVector('versionPart4',weight="A")+SearchVector('versionPart5',weight="A")+SearchVector('versionPart6',weight="A")+SearchVector('versionPart7',weight="A")
                    search_query = SearchQuery(eachEdi)
                    search_rank = SearchRank(search_vector,search_query)
                    cpeQuery = cpeQuery.annotate(rank=search_rank).filter(rank__gt=0.6).order_by('-rank')
            for eachCpe in cpeQuery:
                cveSer = cveVulnerabilitySerializer(eachCpe.cves, many=True)
                data[eachCpe.title] = cveSer.data
            
            return Response(data, status=status.HTTP_200_OK)
        except Exception as e :
            return Response({'details':str(e)}, status=status.HTTP_400_BAD_REQUEST)